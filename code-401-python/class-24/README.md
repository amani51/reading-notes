# Class-24
## Hashtabels
### Introduction
- Hash tables are a data structure in which the address or the index value of the data element is generated from a hash function. That makes accessing the data faster as the index value behaves as a key for the data value. In other words, **Hash table stores key-value pairs but the key is generated through a hashing function.**
![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTaqPwTpIdEZfdwGW0p0CpuVBWPn_vlK15q_w&usqp=CAU)
- So the search and insertion function of a data element becomes much faster as the key values themselves become the index of the array which stores the data.

- In Python, the **Dictionary** data types represent the implementation of hash tables. The Keys in the dictionary satisfy the following requirements.

- The keys of the dictionary are hashable i.e. the are generated by hashing function which generates unique result for each unique value supplied to the hash function.

- The order of data elements in a dictionary is **not fixed.**
- Accessing Values in Dictionary
    To access dictionary elements, you can use the familiar square brackets along with the key to obtain its value.
```python
# Declare a dictionary 
dict = {'Name': 'Eman', 'Age': 12, 'Class': 'Seventh'}

# Accessing the dictionary with its key
print "dict['Name']: ", dict['Name'] #dict['Name']:  Eman
print "dict['Age']: ", dict['Age'] #dict['Age']:  12
```
- Updating Dictionary
    You can update a dictionary by adding a new entry or a key-value pair, modifying an existing entry, or deleting an existing entry
```python
dict['Age'] = 13; # update existing entry
dict['School'] = "Allan School"; # Add new entry
print "dict['Age']: ", dict['Age'] #dict['Age']: 13
print "dict['School']: ", dict['School'] #dict['School']: Allan
```
- Delete Dictionary Elements
    You can either remove individual dictionary elements or clear the entire contents of a dictionary. You can also delete entire dictionary in a single operation.To explicitly remove an entire dictionary, just use the del statement.
    ```python
    dict = {'Name': 'Eman', 'Age': 12, 'Class': 'Seventh'}
    del dict['Name']; # remove entry with key 'Name'
    dict.clear();     # remove all entries in dict
    del dict ;        # delete entire dictionary

    print "dict['Age']: ", dict['Age']
    print "dict['School']: ", dict['School']

    # This produces the following result. Note that an exception is raised because after del dict dictionary does not exist anymore.

    # dict['Age']:
    # Traceback (most recent call last):
    #    File "test.py", line 8, in <module>
    #       print "dict['Age']: ", dict['Age'];
    # TypeError: 'type' object is unsubscriptable
    ```
#### HashTable 
- Let k be a key and h(x) be a hash function.

- Here, h(k) will give us a new index to store the element linked with k.
![](https://cdn.programiz.com/sites/tutorial2program/files/Hash-2_0.png)

##### Hash Collision
- When the hash function generates the same index for multiple keys, there will be a conflict (what value to be stored in that index). This is called a **hash collision**.
- We can resolve the hash collision using one of the following techniques.
    - Collision resolution by chaining
    - Open Addressing: Linear/Quadratic Probing and Double Hashing
##### 1. Collision resolution by chaining
- In chaining, if a hash function produces the same index for multiple elements, these elements are stored in the same index by using a doubly-linked list.

- If j is the slot for multiple elements, it contains a pointer to the head of the list of elements. If no element is present, j contains NIL.
![](https://cdn.programiz.com/sites/tutorial2program/files/Hash-3_1.png)
##### 2. Open Addressing
- open addressing doesn't store multiple elements into the same slot. Here, each slot is either filled with a single key or left NIL.
1. Linear Probing
In linear probing, collision is resolved by checking the next slot.
2. Quadratic Probing
It works similar to linear probing but the spacing between the slots is increased by using the following relation.
3. Double hashing
If a collision occurs after applying a hash function h(k), then another hash function is calculated for finding the next slot.
##### Hash Functions
1. Division Method
2. Multiplication Method

3. Universal Hashing
    In Universal hashing, the hash function is chosen at random independent of keys.
```python
# Python program to demonstrate working of HashTable 

hashTable = [[],] * 10

def checkPrime(n):
    if n == 1 or n == 0:
        return 0

    for i in range(2, n//2):
        if n % i == 0:
            return 0

    return 1


def getPrime(n):
    if n % 2 == 0:
        n = n + 1

    while not checkPrime(n):
        n += 2

    return n


def hashFunction(key):
    capacity = getPrime(10)
    return key % capacity


def insertData(key, data):
    index = hashFunction(key)
    hashTable[index] = [key, data]

def removeData(key):
    index = hashFunction(key)
    hashTable[index] = 0

insertData(123, "apple")
insertData(432, "mango")
insertData(213, "banana")
insertData(654, "guava")

print(hashTable)

removeData(123)

print(hashTable)
```